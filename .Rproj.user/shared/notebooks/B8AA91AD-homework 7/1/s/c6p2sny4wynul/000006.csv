"0","library(MCMCpack)"
"0","delta <- 0.7"
"0","n <- 100"
"0","set.seed(123)"
"0","u <- rbinom(n, prob = delta, size = 1)"
"0","x <- rnorm(n, ifelse(u == 1, 7, 10), 1)"
"0","logpost <- function(theta, x) {"
"0","  delta <- theta[1]"
"0","  mu1 <- theta[2]; mu2 <- theta[3]"
"0","  sig1 <- theta[4]; sig2 <- theta[5]"
"0","  re <- sum(log(delta * dnorm(x, mu1,sqrt(sig1)) +(1-delta)*dnorm(x,mu2,sqrt(sig2))))+log(dnorm(mu1,0,10) ) + log(dnorm(mu2,0,10) ) + log(dinvgamma(sig1, 0.5 , 0.1) ) +  log(dinvgamma(sig2, 0.5 , 0.1) )"
"0","  return(re)"
"0","}"
"0","mymcmc <- function(niter, thetaInit, x, nburn= 100) {"
"0","  p <- length(thetaInit)"
"0","  thetaCurrent <- thetaInit"
"0","  ## define a function for full conditional sampling  "
"0","  logFC <- function(th, idx) {"
"0","    theta <- thetaCurrent"
"0","    theta[idx] <- th"
"0","    logpost(theta, x)"
"0","  }"
"0","  out <- matrix(thetaInit, niter, p, byrow = TRUE)"
"0","  ## Gibbs sampling"
"0","  for (i in 2:niter) {"
"0","    for (j in 1:p) {"
"0","      ## general-purpose arms algorithm"
"0","      out[i, j] <- thetaCurrent[j] <- if (j < 2) {"
"0","        HI::arms(thetaCurrent[j], logFC,"
"0","                 function(x, idx) ((x > 0) * (x < 1)), "
"0","                 1, idx = j)"
"0","      } else if (j < 4 ) { "
"0","        HI::arms(thetaCurrent[j], logFC,"
"0","                 function(x, idx) ((x > -30) * (x < 30)), "
"0","                 1, idx = j)"
"0","      } else {"
"0","        HI::arms(thetaCurrent[j], logFC,"
"0","                 function(x, idx) ((x > 0) * (x < 100)), "
"0","                 1, idx = j)"
"0","      }"
"0","    }"
"0","  }"
"0","  out[-(1:nburn), ]"
"0","}"
"0",""
"0","niter <- 600; nburn <- 100"
"0","thetaInit <- c(0.5, 2, 2, 2, 2)"
"0","sim <- mymcmc(niter, thetaInit, x)"
"0",""
